<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Language Reference</title>

    <link rel="stylesheet" href="./formatting.css">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <nav class="sidebar">
  <h2 class="location">
    <a href="#">Dynasm-rs reference</a>
  </h2>
  <div class="sidebar-elems">
    <h3>Components</h3>
    <ul class="block crate">
      <li>
        <a href="../language/index.html">Syntax</a>
      </li>
      <li>
        <a href="../dynasm/index.html">Plugin (dynasm)</a>
      </li>
      <li>
        <a href="../dynasmrt/index.html">Runtime (dynasmrt)</a>
      </li>
    </ul>
    <h3>Syntax</h3>
    <ul class="block crate">
      <li>
        <a href="./index.html">Home</a>
      </li>
      <li>
        <a href="./tutorial.html">Tutorial</a>
      </li>
      <li>
        <a href="./langref_common.html">Language</a>
      </li>
      <li>
        <a href="./releasenotes.html">Release Notes</a>
      </li>
    </ul>
    <h3>Architectures</h3>
    <h4>x64/x86</h4>
    <ul class="block crate">
      <li>
        <a href="./langref_x64.html">Language dialect</a>
      </li>
      <li>
        <a href="./instructionref_x64.html">Instruction reference</a>
      </li>
    </ul>
    <h4>aarch64</h4>
    <ul class="block crate">
      <li>
        <a href="./langref_aarch64.html">Language dialect</a>
      </li>
      <li>
        <a href="./instructionref_aarch64.html">Instruction reference</a>
      </li>
    </ul>
  </div>
</nav>
<section id="main" class="content mod docblock">

    <h1 class="title">Language Reference</h1>
    <h1 id="lexical-structure-definition"><a class="doc-anchor" href="#lexical-structure-definition">§</a>Lexical structure definition</h1><h2 id="base-units"><a class="doc-anchor" href="#base-units">§</a>Base units</h2>
<p>The following syntax units used in dynasm syntax are defined by the <a href="https://doc.rust-lang.org/grammar.html">Rust grammar</a> itself:</p>
<ul>
<li><code>num_lit</code></li>
<li><code>ident</code></li>
<li><code>expr_path</code></li>
<li><code>expr</code></li>
<li><code>stmt</code></li>
</ul>
<h2 id="entry-point"><a class="doc-anchor" href="#entry-point">§</a>Entry point</h2>
<p>The entry point of dynasm-rs is the dynasm! macro. It is structured as following</p>
<p><code>dynasm : "dynasm" "!" "(" ident (";" line)* ")" ;</code></p>
<p>Where line can be one of the following:</p>
<p><code>line : (";" stmt) | directive | label | instruction ;</code></p>
<h2 id="directives"><a class="doc-anchor" href="#directives">§</a>Directives</h2>
<p>Directives are special commands given to the assembler that do not correspond to instructions directly.
They are executed at parse time, and each directive can have different parsing rules.</p>
<p><code>directive : "." ident directive_parsing_rule;</code></p>
<h2 id="labels"><a class="doc-anchor" href="#labels">§</a>Labels</h2>
<p><code>label : ident ":" | "-&gt;" ident ":" | "=&gt;" expr ;</code>
<code>offset : ("+" | "-") expr</code>
<code>labelref : ("&gt;" ident offset? | "&lt;" ident offset? | "-&gt;" ident offset? | "=&gt;" expr offset? | "extern" expr) ;</code></p>
<h2 id="instructions"><a class="doc-anchor" href="#instructions">§</a>Instructions</h2>
<p>The assembly dialect used by dynasm-rs and parsing rules for it differ based on the target architecture (configured using the <code>.arch</code> directive).
Check the documentation for the specific architecture.</p>
<h1 id="reference"><a class="doc-anchor" href="#reference">§</a>Reference</h1><h2 id="directives-1"><a class="doc-anchor" href="#directives-1">§</a>Directives</h2>
<p>Dynasm-rs currently supports the following directives:</p>
<p>Table 1: dynasm-rs directives</p>
<div><table><thead><tr><th>Name</th><th>Argument format</th><th>Description</th></tr></thead><tbody>
<tr><td><code>.arch</code></td><td>A single identifier</td><td>Specifies the current architecture to assemble. Defaults to the current target architecture. Only <code>x64</code>, <code>x86</code> and <code>aarch64</code> are supported as of now.</td></tr>
<tr><td><code>.feature</code></td><td>A comma-separated list of identifiers.</td><td>Set architectural features that are allowed to be used.</td></tr>
<tr><td><code>.alias</code></td><td>An name followed by a register</td><td>Defines the name as an alias for the wanted register.</td></tr>
<tr><td><code>.align</code></td><td>An expression of type usize</td><td>Pushes NOPs until the assembling head has reached the desired alignment.</td></tr>
<tr><td><code>.u8</code></td><td>One or more expressions of the type <code>u8</code></td><td>Pushes the values into the assembling buffer.</td></tr>
<tr><td><code>.u16</code></td><td>One or more expressions of the type <code>u16</code></td><td>Pushes the values into the assembling buffer.</td></tr>
<tr><td><code>.u32</code></td><td>One or more expressions of the type <code>u32</code></td><td>Pushes the values into the assembling buffer.</td></tr>
<tr><td><code>.u64</code></td><td>One or more expressions of the type <code>u64</code></td><td>Pushes the values into the assembling buffer.</td></tr>
<tr><td><code>.i8</code></td><td>One or more expressions of the type <code>i8</code></td><td>Pushes the values into the assembling buffer.</td></tr>
<tr><td><code>.i16</code></td><td>One or more expressions of the type <code>i16</code></td><td>Pushes the values into the assembling buffer.</td></tr>
<tr><td><code>.i32</code></td><td>One or more expressions of the type <code>i32</code></td><td>Pushes the values into the assembling buffer.</td></tr>
<tr><td><code>.i64</code></td><td>One or more expressions of the type <code>i64</code></td><td>Pushes the values into the assembling buffer.</td></tr>
<tr><td><code>.f32</code></td><td>One or more expressions of the type <code>f32</code></td><td>Pushes the values into the assembling buffer.</td></tr>
<tr><td><code>.f64</code></td><td>One or more expressions of the type <code>f64</code></td><td>Pushes the values into the assembling buffer.</td></tr>
<tr><td><code>.bytes</code></td><td>An expression of that implements <code>IntoIterator&lt;Item=u8&gt;</code> or <code>IntoIterator&lt;Item=&amp;u8&gt;</code></td><td>Extends the assembling buffer with the iterator.</td></tr>
</tbody></table>
</div>
<p>Directives are normally local to the current <code>dynasm!</code> invocation. However, if the <code>filelocal</code> feature is used they will be processed in lexical order over the whole file. This feature only works on a nightly compiler and might be removed in the future.</p>
<h2 id="aliases"><a class="doc-anchor" href="#aliases">§</a>Aliases</h2>
<p>Dynasm-rs allows the user to define aliases for registers using the <code>.alias name, register</code> directive. These aliases can then be used at places where registers are allowed to be used. Note that aliases are defined in lexical parsing order.</p>
<h2 id="macros"><a class="doc-anchor" href="#macros">§</a>Macros</h2>
<p>While this is technically not a feature of dynasm-rs, there are a few rules that must be taken into account when using normal Rust macros with dynasm-rs.</p>
<p>First of all, it is not possible to have <code>dynasm!</code> parse the result of a Rust macro. This is a limitation of Rust itself. The proper way to use Rust macros with dynasm-rs is to have macros expand to a <code>dynasm!</code> call as can be seen in the following example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">macro_rules!</span> fma {
    (<span class="macro-nonterminal">$ops</span>:ident, <span class="macro-nonterminal">$accumulator</span>:expr, <span class="macro-nonterminal">$arg1</span>:expr, <span class="macro-nonterminal">$arg2</span>:expr) =&gt; {<span class="macro">dynasm!</span>(<span class="macro-nonterminal">$ops
        </span>; imul <span class="macro-nonterminal">$arg1</span>, <span class="macro-nonterminal">$arg2
        </span>; add <span class="macro-nonterminal">$accumulator</span>, <span class="macro-nonterminal">$arg1
    </span>)};
}</code></pre></div>
<h2 id="statements"><a class="doc-anchor" href="#statements">§</a>Statements</h2>
<p>To make code that uses a lot of macros less verbose, dynasm-rs allows bare Rust statements to be inserted inside <code>dynasm!</code> invocations. This can be done by using a double semicolon instead of a single semicolon at the start of the line as displayed in the following equivalent examples:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">dynasm!</span>(ops
    ; mov rcx, rax
);
<span class="macro">call_extern!</span>(ops, extern_func);
<span class="macro">dynasm!</span>(ops
    ; mov rcx, rax
);

<span class="macro">dynasm!</span>(ops
    ; mov rcx, rax
    ;; <span class="macro">call_extern!</span>(ops, extern_func)
    ; mov rcx, rax
);</code></pre></div>
<h2 id="labels-1"><a class="doc-anchor" href="#labels-1">§</a>Labels</h2>
<p>In order to describe flow control effectively, dynasm-rs supports labels. However, since the assembly templates can be combined in a variety of ways at the mercy of the program using dynasm-rs, the semantics of these labels are somewhat different from how labels work in a static assembler.</p>
<p>Dynasm-rs distinguishes between four different types of labels: global, local, dynamic and extern. Their syntax is as follows:</p>
<p>Table 2: dynasm-rs label types</p>
<div><table><thead><tr><th>Type</th><th>Kind</th><th>Definition</th><th>Reference</th></tr></thead><tbody>
<tr><td>Local</td><td>static</td><td><code>label:</code></td><td><code>&gt;label</code> or <code>&lt;label</code></td></tr>
<tr><td>GLobal</td><td>static</td><td><code>-&gt;label:</code></td><td><code>-&gt;label</code></td></tr>
<tr><td>Dynamic</td><td>dynamic</td><td><code>=&gt;expr</code></td><td><code>=&gt;expr</code></td></tr>
<tr><td>Extern</td><td>extern</td><td><code>-</code></td><td><code>extern expr</code></td></tr>
</tbody></table>
</div>
<p>All labels have their addresses resolved at <code>Assembler::commit()</code> time.</p>
<p>Any valid Rust identifier is a valid label name.</p>
<h3 id="local-labels"><a class="doc-anchor" href="#local-labels">§</a>Local labels</h3>
<p>On first sight, local label definitions are similar to how labels are normally used in static assemblers. The trick with local labels is however in how they can be referenced. Local labels referenced with the <code>&gt;label</code> syntax will be resolved to the first definition of this label after this piece of code, while local labels referenced with the <code>&lt;label</code> will be resolved to the last definition of this label before the reference site. Any valid Rust identifier can be used as a local label name, and local labels can be defined multiple times.</p>
<h3 id="global-labels"><a class="doc-anchor" href="#global-labels">§</a>Global labels</h3>
<p>Global labels can only be defined once (per-assembler), and all references to a global label will be resolved to this label.</p>
<h3 id="dynamic-labels"><a class="doc-anchor" href="#dynamic-labels">§</a>Dynamic labels</h3>
<p>Dynamic labels are similar to global labels in that they can be defined only once (per-assembler), but instead of a name, they are identified by an expression. New dynamic labels can be created at runtime by the assembler. This expression is evaluated at the point where the label is defined or referenced, and the labels will be resolved at only at commit time.</p>
<h3 id="extern-labels"><a class="doc-anchor" href="#extern-labels">§</a>Extern labels</h3>
<p>Extern labels allow emitted machine code to directly reference fixed addresses as branch targets. This is only supported on architectures featuring absolute branch targets, like <code>x86</code>.</p>

    </section>
<script type="text/javascript">
// make diffs look better, I can't do this in css for some reason and I don't want to hack it into rustdocs

document.addEventListener("DOMContentLoaded", function() {

    var old = document.querySelectorAll("code.language-diffold");
    var old_pre = [];
    for (var i = 0; i < old.length; i++) {
        var old_pre = old[i].parentNode;
        var new_pre = old_pre.nextElementSibling;
        if (new_pre && new_pre.childNodes.length > 0 && new_pre.childNodes[0].className == "language-diffnew") {
            old_pre.className = "collapse-old";
            new_pre.className = "collapse-new";
        }
    }

});
</script>

</body>
</html>