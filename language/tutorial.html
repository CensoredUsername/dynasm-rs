<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Tutorial</title>

    <link rel="stylesheet" type="text/css" href="./formatting.css">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <nav class="sidebar">
  <h2 class="location">
    <a href="#">Language dynasm-rs</a>
  </h2>
  <div class="sidebar-elems">
    <h3>Components</h3>
    <ul class="block crate">
      <li>
        <a href="../language/index.html">Syntax</a>
      </li>
      <li>
        <a href="../dynasm/index.html">Plugin (dynasm)</a>
      </li>
      <li>
        <a href="../dynasmrt/index.html">Runtime (dynasmrt)</a>
      </li>
    </ul>
    <h3>Syntax</h3>
    <ul class="block crate">
      <li>
        <a href="./index.html">Home</a>
      </li>
      <li>
        <a href="./tutorial.html">Tutorial</a>
      </li>
      <li>
        <a href="./langref_common.html">Language</a>
      </li>
      <li>
        <a href="./releasenotes.html">Release Notes</a>
      </li>
    </ul>
    <h3>Architectures</h3>
    <h4>x64/x86</h4>
    <ul class="block crate">
      <li>
        <a href="./langref_x64.html">Language dialect</a>
      </li>
      <li>
        <a href="./instructionref_x64.html">Instruction reference</a>
      </li>
    </ul>
    <h4>aarch64</h4>
    <ul class="block crate">
      <li>
        <a href="./langref_aarch64.html">Language dialect</a>
      </li>
      <li>
        <a href="./instructionref_aarch64.html">Instruction reference</a>
      </li>
    </ul>
  </div>
</nav>
<section id="main" class="content mod docblock">

    <h1 class="title">Tutorial</h1>
    <h1 id="introduction"><a href="#introduction">Introduction</a></h1>
<p>Dynasm-rs is a library and syntax extension for assembling code at runtime. For the first part of the tutorial we will be examining the following example program that assembles a simple function at runtime for the x64 instruction set:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>dynasmrt::{dynasm, DynasmApi, DynasmLabelApi};

<span class="kw">use </span>std::{io, slice, mem};
<span class="kw">use </span>std::io::Write;

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>ops = dynasmrt::x64::Assembler::new().unwrap();
    <span class="kw">let </span>string = <span class="string">&quot;Hello World!&quot;</span>;

    <span class="macro">dynasm!</span>(ops
        ; .arch x64
        ; -&gt;hello:
        ; .bytes string.as_bytes()
    );

    <span class="kw">let </span>hello = ops.offset();
    <span class="macro">dynasm!</span>(ops
        ; .arch x64
        ; lea rcx, [-&gt;hello]
        ; xor edx, edx
        ; mov dl, BYTE string.len() <span class="kw">as _
        </span>; mov rax, QWORD print <span class="kw">as _
        </span>; sub rsp, BYTE <span class="number">0x28
        </span>; call rax
        ; add rsp, BYTE <span class="number">0x28
        </span>; ret
    );

    <span class="kw">let </span>buf = ops.finalize().unwrap();

    <span class="kw">let </span>hello_fn: <span class="kw">extern </span><span class="string">&quot;win64&quot; </span><span class="kw">fn</span>() -&gt; bool = <span class="kw">unsafe </span>{ mem::transmute(buf.ptr(hello)) };

    <span class="macro">assert!</span>(hello_fn());
}

<span class="kw">pub extern </span><span class="string">&quot;win64&quot; </span><span class="kw">fn </span>print(buffer: <span class="kw-2">*const </span>u8, length: u64) -&gt; bool {
    io::stdout()
        .write_all(<span class="kw">unsafe </span>{ slice::from_raw_parts(buffer, length <span class="kw">as </span>usize) })
        .is_ok()
}
</code></pre></div>
<p>We will now examine this code snippet piece by piece.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>dynasmrt::{dynasm, DynasmApi, DynasmLabelApi};</code></pre></div>
<p>We then link to the dynasm runtime crate. We import the <code>dynasmrt::dynasm!</code> macro which will handle all assembling.
Furthermore, the <code>DynasmApi</code> and <code>DynasmLabelApi</code> traits are loaded. These traits define the interfaces used by the <code>dynasm!</code> procedural macro to produce assembled code.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>ops = dynasmrt::x64::Assembler::new();</code></pre></div>
<p>Of course, the machine code that will be generated will need to live somewhere. <code>dynasmrt::x64::Assembler</code> is a struct that implements the <code>DynasmApi</code> and <code>DynasmLabelApi</code> traits, provides storage for the generated machine code, handles memory permissions and provides various utilities for dynamically assembling code. It even allows assembling code in one thread while several other threads execute said code. For this example though, we will use it in the most simple use case, just assembling everything in advance and then executing it.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">dynasm!</span>(ops
    ; .arch x64
    ; -&gt;hello:
    ; .bytes string.as_bytes()
);</code></pre></div>
<p>The first invocation of the <code>dynasm!</code> macro shows of three features of dynasm. <code>.arch x64</code> is a directive that specifies the current assembling architecture. By default this is set to the compiler target architecture, but we repeat it here to show it clearly. The second line defines a global label <code>hello</code> which later can be referenced, and the third line contains another assembler directive. Assembler directives allow the assembler to perform tasks that do not involve instruction assembling like, in this case, inserting a string into the executable buffer.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>hello = ops.offset();</code></pre></div>
<p>This utility function returns a value indicating the position of the current end of the machine code buffer. It can later be used to obtain a pointer to this position in the generated machine code.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">dynasm!</span>(ops
    ; .arch x64
    ; lea rcx, [-&gt;hello]
    ; xor edx, edx
    ; mov dl, BYTE string.len() <span class="kw">as _
    </span>; mov rax, QWORD print <span class="kw">as _
    </span>; sub rsp, BYTE <span class="number">0x28
    </span>; call rax
    ; add rsp, BYTE <span class="number">0x28
    </span>; ret
);</code></pre></div>
<p>The second invocation of the <code>dynasm!</code> macro contains the definition of a small function. It performs the following tasks:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>; lea rcx, [-&gt;hello]</code></pre></div>
<p>First, the address of the global label <code>-&gt;hello</code> is loaded using the load effective address instruction and a label memory reference.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>; xor edx, edx
; mov dl, BYTE string.len() <span class="kw">as _</span></code></pre></div>
<p>Then the length of the string is loaded. Here the <code>BYTE</code> prefix determines the size of the immediate in the second instruction. the <code>as _</code> cast is necessary to coerce the size of the length down to the <code>i8</code> type expected of an immediate. Dynasm-rs tries to avoid performing implicit casts as this tends to hide errors.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>; mov rax, QWORD print <span class="kw">as _
</span>; sub rsp, BYTE <span class="number">0x28
</span>; call rax
; add rsp, BYTE <span class="number">0x28</span></code></pre></div>
<p>Here, a call is made from the dynamically assembled code to the Rust <code>print</code> function. Note the <code>QWORD</code> size prefix which is necessary to determine the appropriate form of the <code>mov</code> instruction to encode as <code>dynasm!</code> does not analyze the immediate expression at runtime. As this example uses the <code>&quot;win64&quot;</code> calling convention, the stack pointer needs to be manipulated too. (Note: the <code>&quot;win64&quot;</code> calling convention is used as this it is currently impossible to use the <code>&quot;sysv64&quot;</code> calling convention on all platforms)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>; ret</code></pre></div>
<p>And finally the assembled function returns, returning the return value from the <code>print</code> function in <code>rax</code> back to the caller Rust code.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>buf = ops.finalize().unwrap();</code></pre></div>
<p>With the assembly completed, we now finalize the <code>dynasmrt::x64::Assembler</code>, which will resolve all labels previously used and move the data into a <code>dynasmrt::ExecutableBuffer</code>. This struct, which dereferences to a <code>&amp;[u8]</code>, wraps a buffer of readable and executable memory.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>hello_fn: <span class="kw">extern </span><span class="string">&quot;win64&quot; </span><span class="kw">fn</span>() -&gt; bool = <span class="kw">unsafe </span>{ mem::transmute(buf.ptr(hello)) };</code></pre></div>
<p>We can now get a pointer to the executable memory using the <code>dynasmrt::ExecutableBuffer::ptr</code> method, using the value obtained earlier from <code>ops.offset()</code>. We can then transmute this pointer into a function.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(hello_fn());</code></pre></div>
<p>And finally we can call this function, asserting that it returns true to confirm that it managed to print the encoded message!</p>
<p>For the people interested in the behind-the-scenes, here’s what the <code>dynasm!</code> macros expand to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>ops = dynasmrt::x64::Assembler::new().unwrap();
    <span class="kw">let </span>string = <span class="string">&quot;Hello World!&quot;</span>;

    {
        ops.global_label(<span class="string">&quot;hello&quot;</span>);
        ops.extend(string.as_bytes());
    };

    <span class="kw">let </span>hello = ops.offset();
    {
        ops.extend(<span class="string">b&quot;H\x8d\r\x00\x00\x00\x00&quot;</span>);
        ops.global_reloc(<span class="string">&quot;hello&quot;</span>, <span class="number">0isize</span>, <span class="number">4u8</span>, <span class="number">0u8</span>, (<span class="number">4u8</span>,));
        ops.extend(<span class="string">b&quot;1\xd2\xb2&quot;</span>);
        ops.push_i8(string.len() <span class="kw">as _</span>);
        ops.extend(<span class="string">b&quot;H\xb8&quot;</span>);
        ops.push_i64(print <span class="kw">as _</span>);
        ops.extend(<span class="string">b&quot;H\x83\xec&quot;</span>);
        ops.push_i8(<span class="number">0x28</span>);
        ops.extend(<span class="string">b&quot;\xff\xd0H\x83\xc4&quot;</span>);
        ops.push_i8(<span class="number">0x28</span>);
        ops.extend(<span class="string">b&quot;\xc3&quot;</span>);
    };

    <span class="kw">let </span>buf = ops.finalize().unwrap();

    <span class="kw">let </span>hello_fn: <span class="kw">extern </span><span class="string">&quot;win64&quot; </span><span class="kw">fn</span>() -&gt; bool = <span class="kw">unsafe </span>{ mem::transmute(buf.ptr(hello)) };

    <span class="macro">assert!</span>(hello_fn());
}</code></pre></div>
<p>As you can see, the encoding has been determined fully at compile time, and the assembly has been reduced to a series of push and extend calls.</p>
<h1 id="advanced-usage"><a href="#advanced-usage">Advanced usage</a></h1>
<p>To demonstrate some of the more advanced usage, we’ll show how to rewrite a Rust brainfsck interpreter to a jit compiler. The starting point is the following interpreter that can also be found <a href="https://github.com/CensoredUsername/dynasm-rs/tree/master/doc/examples/bf-interpreter">here</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::{Read, BufRead, Write, stdin, stdout, BufReader, BufWriter};
<span class="kw">use </span>std::env;
<span class="kw">use </span>std::fs::File;

<span class="kw">const </span>TAPE_SIZE: usize = <span class="number">30000</span>;

<span class="kw">struct </span>Interpreter&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">pub </span>input: Box&lt;<span class="kw">dyn </span>BufRead + <span class="lifetime">&#39;a</span>&gt;,
    <span class="kw">pub </span>output: Box&lt;<span class="kw">dyn </span>Write + <span class="lifetime">&#39;a</span>&gt;,
    <span class="kw">pub </span>loops: Vec&lt;usize&gt;,
    <span class="kw">pub </span>tape: [u8; TAPE_SIZE],
    <span class="kw">pub </span>tape_index: usize,
    <span class="kw">pub </span>pos: usize
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Interpreter&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>new(input: Box&lt;<span class="kw">dyn </span>BufRead + <span class="lifetime">&#39;a</span>&gt;, output: Box&lt;<span class="kw">dyn </span>Write + <span class="lifetime">&#39;a</span>&gt;) -&gt; Interpreter&lt;<span class="lifetime">&#39;a</span>&gt; {
        Interpreter {
            input: input,
            output: output,
            loops: Vec::new(),
            tape: [<span class="number">0</span>; TAPE_SIZE],
            tape_index: <span class="number">0</span>,
            pos: <span class="number">0
        </span>}
    }

    <span class="kw">fn </span>run(<span class="kw-2">&amp;mut </span><span class="self">self</span>, program: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;(), <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str&gt; {
        <span class="kw">while let </span><span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>c) = program.get(<span class="self">self</span>.pos) {
            <span class="self">self</span>.pos += <span class="number">1</span>;

            <span class="kw">match </span>c {
                <span class="string">b&#39;&lt;&#39; </span>=&gt; {
                    <span class="kw">let </span>amount = count_leading_chars(<span class="kw-2">&amp;</span>program[<span class="self">self</span>.pos..], <span class="string">b&#39;&lt;&#39;</span>);
                    <span class="self">self</span>.pos += amount;

                    <span class="self">self</span>.tape_index = <span class="self">self</span>.tape_index.wrapping_sub(amount + <span class="number">1</span>);
                    <span class="kw">while </span><span class="self">self</span>.tape_index &gt;= TAPE_SIZE {
                        <span class="self">self</span>.tape_index = <span class="self">self</span>.tape_index.wrapping_add(TAPE_SIZE);
                    }
                },
                <span class="string">b&#39;&gt;&#39; </span>=&gt; {
                    <span class="kw">let </span>amount = count_leading_chars(<span class="kw-2">&amp;</span>program[<span class="self">self</span>.pos..], <span class="string">b&#39;&gt;&#39;</span>);
                    <span class="self">self</span>.pos += amount;

                    <span class="self">self</span>.tape_index += amount + <span class="number">1</span>;
                    <span class="kw">while </span><span class="self">self</span>.tape_index &gt;= TAPE_SIZE {
                        <span class="self">self</span>.tape_index -= TAPE_SIZE;
                    }
                },
                <span class="string">b&#39;+&#39; </span>=&gt; {
                    <span class="kw">let </span>amount = count_leading_chars(<span class="kw-2">&amp;</span>program[<span class="self">self</span>.pos..], <span class="string">b&#39;+&#39;</span>);
                    <span class="self">self</span>.pos += amount;
                    <span class="kw">if let </span><span class="prelude-val">Some</span>(a) = <span class="self">self</span>.tape[<span class="self">self</span>.tape_index].checked_add(amount <span class="kw">as </span>u8 + <span class="number">1</span>) {
                        <span class="self">self</span>.tape[<span class="self">self</span>.tape_index] = a;
                    } <span class="kw">else </span>{
                        <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="string">&quot;An overflow occurred&quot;</span>);
                    }
                },
                <span class="string">b&#39;-&#39; </span>=&gt; {
                    <span class="kw">let </span>amount = count_leading_chars(<span class="kw-2">&amp;</span>program[<span class="self">self</span>.pos..], <span class="string">b&#39;-&#39;</span>);
                    <span class="self">self</span>.pos += amount;
                    <span class="kw">if let </span><span class="prelude-val">Some</span>(a) = <span class="self">self</span>.tape[<span class="self">self</span>.tape_index].checked_sub(amount <span class="kw">as </span>u8 + <span class="number">1</span>) {
                        <span class="self">self</span>.tape[<span class="self">self</span>.tape_index] = a;
                    } <span class="kw">else </span>{
                        <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="string">&quot;An overflow occurred&quot;</span>);
                    }
                },
                <span class="string">b&#39;,&#39; </span>=&gt; {
                    <span class="kw">let </span>err = <span class="self">self</span>.output.flush().is_err();
                    <span class="kw">if </span><span class="self">self</span>.input.read_exact(<span class="kw-2">&amp;mut </span><span class="self">self</span>.tape[<span class="self">self</span>.tape_index..<span class="self">self</span>.tape_index + <span class="number">1</span>]).is_err() || err {
                        <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="string">&quot;IO error&quot;</span>);
                    }
                },
                <span class="string">b&#39;.&#39; </span>=&gt; {
                    <span class="kw">if </span><span class="self">self</span>.output.write_all(<span class="kw-2">&amp;</span><span class="self">self</span>.tape[<span class="self">self</span>.tape_index..<span class="self">self</span>.tape_index + <span class="number">1</span>]).is_err() {
                        <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="string">&quot;IO error&quot;</span>);
                    }
                },
                <span class="string">b&#39;[&#39; </span>=&gt; {
                    <span class="kw">if </span><span class="self">self</span>.tape[<span class="self">self</span>.tape_index] == <span class="number">0 </span>{
                        <span class="kw">let </span><span class="kw-2">mut </span>nesting = <span class="number">1</span>;
                        <span class="kw">let </span>amount = program[<span class="self">self</span>.pos..].iter().take_while(|x| <span class="kw">match </span><span class="kw-2">**</span>x {
                            <span class="string">b&#39;[&#39; </span>=&gt; {nesting += <span class="number">1</span>; <span class="bool-val">true</span>},
                            <span class="string">b&#39;]&#39; </span>=&gt; {nesting -= <span class="number">1</span>; nesting != <span class="number">0</span>},
                            <span class="kw">_ </span>=&gt; <span class="bool-val">true
                        </span>}).count() + <span class="number">1</span>;
                        <span class="kw">if </span>nesting != <span class="number">0 </span>{
                            <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="string">&quot;[ without matching ]&quot;</span>);
                        }
                        <span class="self">self</span>.pos += amount;
                    } <span class="kw">else </span>{
                        <span class="self">self</span>.loops.push(<span class="self">self</span>.pos);
                    }
                },
                <span class="string">b&#39;]&#39; </span>=&gt; {
                    <span class="kw">if </span><span class="self">self</span>.tape[<span class="self">self</span>.tape_index] == <span class="number">0 </span>{
                        <span class="self">self</span>.loops.pop();
                    } <span class="kw">else if let </span><span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>loc) = <span class="self">self</span>.loops.last() {
                        <span class="self">self</span>.pos = loc;
                    } <span class="kw">else </span>{
                        <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="string">&quot;] without matching [&quot;</span>);
                    }
                },
                <span class="kw">_ </span>=&gt; ()
            }
        }

        <span class="kw">if </span><span class="self">self</span>.loops.len() != <span class="number">0 </span>{
            <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="string">&quot;[ without matching ]&quot;</span>);
        }
        <span class="prelude-val">Ok</span>(())
    }
}

<span class="kw">fn </span>count_leading_chars(program: <span class="kw-2">&amp;</span>[u8], c: u8) -&gt; usize {
    program.iter().take_while(|x| <span class="kw-2">**</span>x == c).count()
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>args: Vec&lt;<span class="kw">_</span>&gt; = env::args().collect();
    <span class="kw">if </span>args.len() != <span class="number">2 </span>{
        <span class="macro">println!</span>(<span class="string">&quot;Expected 1 argument, got {}&quot;</span>, args.len());
        <span class="kw">return</span>;
    }
    <span class="kw">let </span>path = args.pop().unwrap();

    <span class="kw">let </span><span class="kw-2">mut </span>f = <span class="kw">if let </span><span class="prelude-val">Ok</span>(f) = File::open(<span class="kw-2">&amp;</span>path) { f } <span class="kw">else </span>{
        <span class="macro">println!</span>(<span class="string">&quot;Could not open file {}&quot;</span>, path);
        <span class="kw">return</span>;
    };

    <span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();
    <span class="kw">if let </span><span class="prelude-val">Err</span>(<span class="kw">_</span>) = f.read_to_end(<span class="kw-2">&amp;mut </span>buf) {
        <span class="macro">println!</span>(<span class="string">&quot;Failed to read from file&quot;</span>);
        <span class="kw">return</span>;
    }

    <span class="kw">let </span><span class="kw-2">mut </span>interp = Interpreter::new(
        Box::new(BufReader::new(stdin())), 
        Box::new(BufWriter::new(stdout()))
    );
    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = interp.run(<span class="kw-2">&amp;</span>buf) {
        <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, e);
    }
}</code></pre></div>
<h2 id="basics"><a href="#basics">Basics</a></h2>
<p>To kickstart this process, we’ll <code>use</code> the <code>dynasm!</code> macro as well as the <code>DynasmApi</code> and <code>DynasmLabelApi</code> traits:</p>
<div class="example-wrap"><pre class="language-diffnew"><code>+ use dynasmrt::{dynasm, DynasmApi, DynasmLabelApi};
</code></pre></div>
<p>Next, we’ll define our own custom dynasm macro which first defines the current architecture as well as several aliases we’d like to use when writing the rest of the code.</p>
<div class="example-wrap"><pre class="language-diffnew"><code>+ macro_rules! my_dynasm {
+     ($ops:ident $($t:tt)*) =&gt; {
+         dynasm!($ops
+             ; .arch x64
+             ; .alias a_state, rcx
+             ; .alias a_current, rdx
+             ; .alias a_begin, r8
+             ; .alias a_end, r9
+             ; .alias retval, rax
+             $($t)*
+         )
+     }
+ }
</code></pre></div>
<p>We can now define several utility macros to handle common operations in the code.</p>
<div class="example-wrap"><pre class="language-diffnew"><code>+ macro_rules! prologue {
+     ($ops:ident) =&gt; {{
+         let start = $ops.offset();
+         my_dynasm!($ops
+             ; sub rsp, 0x28
+             ; mov [rsp + 0x30], rcx
+             ; mov [rsp + 0x40], r8
+             ; mov [rsp + 0x48], r9
+         );
+         start
+     }};
+ }
+ 
+ macro_rules! epilogue {
+     ($ops:ident, $e:expr) =&gt; {my_dynasm!($ops
+         ; mov retval, $e
+         ; add rsp, 0x28
+         ; ret
+     );};
+ }
+ 
+ macro_rules! call_extern {
+     ($ops:ident, $addr:expr) =&gt; {my_dynasm!($ops
+         ; mov [rsp + 0x38], rdx
+         ; mov rax, QWORD $addr as _
+         ; call rax
+         ; mov rcx, [rsp + 0x30]
+         ; mov rdx, [rsp + 0x38]
+         ; mov r8,  [rsp + 0x40]
+         ; mov r9,  [rsp + 0x48]
+     );};
+ }
</code></pre></div><h2 id="state"><a href="#state">State</a></h2>
<p>Looking at the state of the interpreter, it contains a lot of fields that the jit compiler doesn’t need. We therefore reduce the state and we define a second struct which will hold the compiled machine code:</p>
<div class="example-wrap"><pre class="language-diffold"><code>- struct Interpreter&lt;&#39;a&gt; {
-     pub input: Box&lt;BufRead + &#39;a&gt;,
-     pub output: Box&lt;Write + &#39;a&gt;,
-     pub loops: Vec&lt;usize&gt;,
-     pub tape: [u8; TAPE_SIZE],
-     pub tape_index: usize,
-     pub pos: usize
- }
</code></pre></div><div class="example-wrap"><pre class="language-diffnew"><code>+ struct State&lt;&#39;a&gt; {
+     pub input: Box&lt;BufRead + &#39;a&gt;,
+     pub output: Box&lt;Write + &#39;a&gt;,
+     tape: [u8; TAPE_SIZE]
+ }
+ 
+ struct Program {
+     code: dynasmrt::ExecutableBuffer,
+     start: dynasmrt::AssemblyOffset,
+ }
</code></pre></div><h2 id="compiler"><a href="#compiler">Compiler</a></h2>
<p>With the state defined, we can now start adapting the <code>Interpreter::run</code> method into <code>Program::compile</code>, starting with initalization code. We initialize an assembler and a <code>Vec</code> to hold the loops stack. As we will only parse through the code once, replace the slice indexing by an iterator that allows us to look ahead, courtesy of the <code>itertools</code> crate. We get the starting offset and emit the function prologue and finally we start iterating through the program:</p>
<div class="example-wrap"><pre class="language-diffold"><code>- impl&lt;&#39;a&gt; Interpreter&lt;&#39;a&gt; {
-     fn new(input: Box&lt;BufRead + &#39;a&gt;, output: Box&lt;Write + &#39;a&gt;) -&gt; Interpreter&lt;&#39;a&gt; {
-         Interpreter {
-             input: input,
-             output: output,
-             loops: Vec::new(),
-             tape: [0; TAPE_SIZE],
-             tape_index: 0,
-             pos: 0
-         }
-     }
- 
-     fn run(&amp;mut self, program: &amp;[u8]) -&gt; Result&lt;(), &amp;&#39;static str&gt; {
-         while let Some(&amp;c) = program.get(self.pos) {
-             self.pos += 1;
</code></pre></div><div class="example-wrap"><pre class="language-diffnew"><code>+ impl Program {
+     fn compile(program: &amp;[u8]) -&gt; Result&lt;Program, &amp;&#39;static str&gt; {
+         let mut ops = dynasmrt::x64::Assembler::new().unwrap();
+         let mut loops = Vec::new();
+         let mut code = multipeek(program.iter().cloned());
+ 
+         let start = prologue!(ops);
+ 
+         while let Some(c) = code.next() {
</code></pre></div><h3 id="tape-movement"><a href="#tape-movement">Tape movement</a></h3>
<p>We can now replace the the tape movement by an optimized assembly version. Note the local label used to implement tape wraparound:</p>
<div class="example-wrap"><pre class="language-diffold"><code>- let amount = count_leading_chars(&amp;program[self.pos..], b&#39;&lt;&#39;);
- self.pos += amount;
- 
- self.tape_index = self.tape_index.wrapping_sub(amount + 1);
- while self.tape_index &gt;= TAPE_SIZE {
-     self.tape_index = self.tape_index.wrapping_add(TAPE_SIZE);
- }
</code></pre></div><div class="example-wrap"><pre class="language-diffnew"><code>+ let amount = code.take_while_ref(|x| *x == b&#39;&lt;&#39;).count() + 1;
+ my_dynasm!(ops
+     ; sub a_current, (amount % TAPE_SIZE) as _
+     ; cmp a_current, a_begin
+     ; jae &gt;wrap
+     ; add a_current, TAPE_SIZE as _
+     ;wrap:
+ );
</code></pre></div><div class="example-wrap"><pre class="language-diffold"><code>- let amount = count_leading_chars(&amp;program[self.pos..], b&#39;&gt;&#39;);
- self.pos += amount;
- self.tape_index += amount + 1;
- while self.tape_index &gt;= TAPE_SIZE {
-     self.tape_index -= TAPE_SIZE;
- }
</code></pre></div><div class="example-wrap"><pre class="language-diffnew"><code>+ let amount = code.take_while_ref(|x| *x == b&#39;&gt;&#39;).count() + 1;
+ my_dynasm!(ops
+     ; add a_current, (amount % TAPE_SIZE) as _
+     ; cmp a_current, a_end
+     ; jb &gt;wrap
+     ; sub a_current, TAPE_SIZE as _
+     ;wrap:
+ );
</code></pre></div><h3 id="arithmetric"><a href="#arithmetric">Arithmetric</a></h3>
<p>The <code>+</code> and <code>-</code> instructions have by far the most simple implementations. Note that when an overflow occurs at runtime, we jump to the <code>-&gt;overflow:</code> global label (Note: overflow is somewhat ill-defined in brainfsck, but in the spirit of Rust I decided that everything that can be checked should be checked):</p>
<div class="example-wrap"><pre class="language-diffold"><code>- let amount = count_leading_chars(&amp;program[self.pos..], b&#39;+&#39;);
- self.pos += amount;
- if let Some(a) = self.tape[self.tape_index].checked_add(amount as u8 + 1) {
-     self.tape[self.tape_index] = a;
- } else {
-     return Err(&quot;An overflow occurred&quot;);
- }
</code></pre></div><div class="example-wrap"><pre class="language-diffnew"><code>+ let amount = code.take_while_ref(|x| *x == b&#39;+&#39;).count() + 1;
+ if amount &gt; u8::MAX as usize {
+     return Err(&quot;An overflow occurred&quot;);
+ }
+ my_dynasm!(ops
+     ; add BYTE [a_current], amount as _
+     ; jo -&gt;overflow
+ );
</code></pre></div><div class="example-wrap"><pre class="language-diffold"><code>- let amount = count_leading_chars(&amp;program[self.pos..], b&#39;-&#39;);
- self.pos += amount;
- if let Some(a) = self.tape[self.tape_index].checked_sub(amount as u8 + 1) {
-     self.tape[self.tape_index] = a;
- } else {
-     return Err(&quot;An overflow occurred&quot;);
- }
</code></pre></div><div class="example-wrap"><pre class="language-diffnew"><code>+ let amount = code.take_while_ref(|x| *x == b&#39;-&#39;).count() + 1;
+ if amount &gt; u8::MAX as usize {
+     return Err(&quot;An overflow occurred&quot;);
+ }
+ my_dynasm!(ops
+     ; sub BYTE [a_current], amount as _
+     ; jo -&gt;overflow
+ );
</code></pre></div><h3 id="io"><a href="#io">I/O</a></h3>
<p>As the input and output fields of state are implemented as trait objects, we need to handle the virtual call to them in Rust code. Therefore, we first define the following wrapper methods on <code>State</code>:</p>
<div class="example-wrap"><pre class="language-diffnew"><code>impl&lt;&#39;a&gt; State&lt;&#39;a&gt; {
    unsafe extern &quot;win64&quot; fn getchar(state: *mut State, cell: *mut u8) -&gt; u8 {
        let state = &amp;mut *state;
        let err = state.output.flush().is_err();
        (state.input.read_exact(slice::from_raw_parts_mut(cell, 1)).is_err() || err) as u8
    }

    unsafe extern &quot;win64&quot; fn putchar(state: *mut State, cell: *mut u8) -&gt; u8 {
        let state = &amp;mut *state;
        state.output.write_all(slice::from_raw_parts(cell, 1)).is_err() as u8
    }
</code></pre></div>
<p>We can then simply call these methods directly from the compiled code. If the I/O functions failed, we jump to the <code>-&gt;io_failure</code> global label:</p>
<div class="example-wrap"><pre class="language-diffold"><code>- let err = self.output.flush().is_err();
- if self.input.read_exact(&amp;mut self.tape[self.tape_index..self.tape_index + 1]).is_err() || err {
-     return Err(&quot;IO error&quot;);
- }
</code></pre></div><div class="example-wrap"><pre class="language-diffnew"><code>+ my_dynasm!(ops
+     ;; call_extern!(ops, State::getchar)
+     ; cmp al, 0
+     ; jnz -&gt;io_failure
+ );
</code></pre></div><div class="example-wrap"><pre class="language-diffold"><code>- if self.output.write_all(&amp;self.tape[self.tape_index..self.tape_index + 1]).is_err() {
-     return Err(&quot;IO error&quot;);
- }
</code></pre></div><div class="example-wrap"><pre class="language-diffnew"><code>+ my_dynasm!(ops
+     ;; call_extern!(ops, State::putchar)
+     ; cmp al, 0
+     ; jnz -&gt;io_failure
+ );
</code></pre></div><h3 id="loops"><a href="#loops">Loops</a></h3>
<p>The <code>[</code> and <code>]</code> commands have the most complex implementation. When a <code>[</code> is encountered, we need to declare two dynamic labels. One to jump to after the <code>]</code> when the current tape value is 0 and another to jump from the <code>]</code> to just after the <code>[</code> when the current tape value is not 0. Additionally, we special case the sequence <code>[-]</code> which is often used to set the current tape value to 0 and emit optimized machine code for it.</p>
<div class="example-wrap"><pre class="language-diffold"><code>- if self.tape[self.tape_index] == 0 {
-     let mut nesting = 1;
-     let amount = program[self.pos..].iter().take_while(|x| match **x {
-         b&#39;[&#39; =&gt; {nesting += 1; true},
-         b&#39;]&#39; =&gt; {nesting -= 1; nesting != 0},
-         _ =&gt; true
-     }).count() + 1;
-     if nesting != 0 {
-         return Err(&quot;[ without matching ]&quot;);
-     }
-     self.pos += amount;
- } else {
-     self.loops.push(self.pos);
- }
</code></pre></div><div class="example-wrap"><pre class="language-diffnew"><code>+ let first = code.peek() == Some(&amp;b&#39;-&#39;);
+ if first &amp;&amp; code.peek() == Some(&amp;b&#39;]&#39;) {
+     code.next();
+     code.next();
+     my_dynasm!(ops
+         ; mov BYTE [a_current], 0
+     );
+ } else {
+     let backward_label = ops.new_dynamic_label();
+     let forward_label  = ops.new_dynamic_label();
+     loops.push((backward_label, forward_label));
+     my_dynasm!(ops
+         ; cmp BYTE [a_current], 0
+         ; jz =&gt;forward_label
+         ;=&gt;backward_label
+     );
+ }
</code></pre></div><div class="example-wrap"><pre class="language-diffold"><code>- if self.tape[self.tape_index] == 0 {
-     self.loops.pop();
- } else if let Some(&amp;loc) = self.loops.last() {
-     self.pos = loc;
- } else {
-     return Err(&quot;] without matching [&quot;);
- }
</code></pre></div><div class="example-wrap"><pre class="language-diffnew"><code>+ if let Some((backward_label, forward_label)) = loops.pop() {
+     my_dynasm!(ops
+         ; cmp BYTE [a_current], 0
+         ; jnz =&gt;backward_label
+         ;=&gt;forward_label
+     );
+ } else {
+     return Err(&quot;] without matching [&quot;);
+ },
</code></pre></div><h3 id="epilogue"><a href="#epilogue">Epilogue</a></h3>
<p>With the end of the parsing reached, we must now handle the return and possible error conditions. This is done by returning 0 if the execution was successful, or an error code when an error happened at runtime.</p>
<div class="example-wrap"><pre class="language-diffnew"><code>+ my_dynasm!(ops
+     ;; epilogue!(ops, 0)
+     ;-&gt;overflow:
+     ;; epilogue!(ops, 1)
+     ;-&gt;io_failure:
+     ;; epilogue!(ops, 2)
+ );
</code></pre></div>
<p>Now we can finalize the assembler and construct a Program from the resulting buffer:</p>
<div class="example-wrap"><pre class="language-diffold"><code>- Ok(())
</code></pre></div><div class="example-wrap"><pre class="language-diffnew"><code>+ let code = ops.finalize().unwrap();
+ Ok(Program {
+     code: code,
+     start: start
+ })
</code></pre></div><h2 id="calling-the-compiled-code"><a href="#calling-the-compiled-code">Calling the compiled code</a></h2>
<p>First, we add an initializer method to <code>State</code>:</p>
<div class="example-wrap"><pre class="language-diffnew"><code>+ fn new(input: Box&lt;BufRead + &#39;a&gt;, output: Box&lt;Write + &#39;a&gt;) -&gt; State&lt;&#39;a&gt; {
+     State {
+         input: input,
+         output: output,
+         tape: [0; TAPE_SIZE]
+     }
+ }
</code></pre></div>
<p>Then, we add a <code>run</code> method on <code>Program</code>. This method does the following:</p>
<ul>
<li>Transmute a pointer to the start of our compiled data to a function. This is the one <code>unsafe</code> block always needed when using Dynasm-rs, but it is probably the most dangerous one you’ll ever find.</li>
<li>Create the input arguments to the function from a <code>State</code>. Since the <code>&quot;win64&quot;</code> calling convention is used these arguments will end up in the registers <code>rcx</code>, <code>rdx</code>, <code>r8</code> and <code>r9</code>.</li>
<li>Run the function.</li>
<li>Return a <code>Result</code> based on the error code returned by the function.</li>
</ul>
<div class="example-wrap"><pre class="language-diffnew"><code>+ fn run(self, state: &amp;mut State) -&gt; Result&lt;(), &amp;&#39;static str&gt; {
+     let f: extern &quot;win64&quot; fn(*mut State, *mut u8, *mut u8, *const u8) -&gt; u8 = unsafe {
+         mem::transmute(self.code.ptr(self.start))
+     };
+     let start = state.tape.as_mut_ptr();
+     let end = unsafe { start.offset(TAPE_SIZE as isize) };
+     let res = f(state, start, start, end);
+     if res == 0 {
+         Ok(())
+     } else if res == 1 {
+         Err(&quot;An overflow occurred&quot;)
+     } else if res == 2 {
+         Err(&quot;IO error&quot;)
+     } else {
+         panic!(&quot;Unknown error code&quot;);
+     }
+ }
</code></pre></div>
<p>And finally, we can edit the <code>main</code> function to use the JIT:</p>
<div class="example-wrap"><pre class="language-diffold"><code>- let mut interp = Interpreter::new(
-     Box::new(BufReader::new(stdin())), 
-     Box::new(BufWriter::new(stdout()))
- );
- if let Err(e) = interp.run(&amp;buf) {
-     println!(&quot;{}&quot;, e);
- }
</code></pre></div><div class="example-wrap"><pre class="language-diffnew"><code>+ let mut state = State::new(
+     Box::new(BufReader::new(stdin())), 
+     Box::new(BufWriter::new(stdout()))
+ );
+ let program = match Program::compile(&amp;buf) {
+     Ok(p) =&gt; p,
+     Err(e) =&gt; {
+         println!(&quot;{}&quot;, e);
+         return;
+     }
+ };
+ if let Err(e) = program.run(&amp;mut state) {
+     println!(&quot;{}&quot;, e);
+     return;
+ }
</code></pre></div><h2 id="result"><a href="#result">Result</a></h2>
<p>With these changes, adding the necessary <code>use</code> statements and removing unused functions, you should end up with the following code (you can also find this example <a href="https://github.com/CensoredUsername/dynasm-rs/tree/master/doc/examples/bf-jit">here</a>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>dynasmrt::{dynasm, DynasmApi, DynasmLabelApi};

<span class="kw">use </span>itertools::Itertools;
<span class="kw">use </span>itertools::multipeek;

<span class="kw">use </span>std::io::{Read, BufRead, Write, stdin, stdout, BufReader, BufWriter};
<span class="kw">use </span>std::env;
<span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::slice;
<span class="kw">use </span>std::mem;
<span class="kw">use </span>std::u8;

<span class="kw">const </span>TAPE_SIZE: usize = <span class="number">30000</span>;

<span class="macro">macro_rules! </span>my_dynasm {
    (<span class="macro-nonterminal">$ops</span>:ident $(<span class="macro-nonterminal">$t</span>:tt)<span class="kw-2">*</span>) =&gt; {
        <span class="macro">dynasm!</span>(<span class="macro-nonterminal">$ops
            </span>; .arch x64
            ; .alias a_state, rcx
            ; .alias a_current, rdx
            ; .alias a_begin, r8
            ; .alias a_end, r9
            ; .alias retval, rax
            $(<span class="macro-nonterminal">$t</span>)*
        )
    }
}

<span class="macro">macro_rules! </span>prologue {
    (<span class="macro-nonterminal">$ops</span>:ident) =&gt; {{
        <span class="kw">let </span>start = <span class="macro-nonterminal">$ops</span>.offset();
        <span class="macro">my_dynasm!</span>(<span class="macro-nonterminal">$ops
            </span>; sub rsp, <span class="number">0x28
            </span>; mov [rsp + <span class="number">0x30</span>], rcx
            ; mov [rsp + <span class="number">0x40</span>], r8
            ; mov [rsp + <span class="number">0x48</span>], r9
        );
        start
    }};
}

<span class="macro">macro_rules! </span>epilogue {
    (<span class="macro-nonterminal">$ops</span>:ident, <span class="macro-nonterminal">$e</span>:expr) =&gt; {<span class="macro">my_dynasm!</span>(<span class="macro-nonterminal">$ops
        </span>; mov retval, <span class="macro-nonterminal">$e
        </span>; add rsp, <span class="number">0x28
        </span>; ret
    );};
}

<span class="macro">macro_rules! </span>call_extern {
    (<span class="macro-nonterminal">$ops</span>:ident, <span class="macro-nonterminal">$addr</span>:expr) =&gt; {<span class="macro">my_dynasm!</span>(<span class="macro-nonterminal">$ops
        </span>; mov [rsp + <span class="number">0x38</span>], rdx
        ; mov rax, QWORD <span class="macro-nonterminal">$addr </span><span class="kw">as _
        </span>; call rax
        ; mov rcx, [rsp + <span class="number">0x30</span>]
        ; mov rdx, [rsp + <span class="number">0x38</span>]
        ; mov r8,  [rsp + <span class="number">0x40</span>]
        ; mov r9,  [rsp + <span class="number">0x48</span>]
    );};
}

<span class="kw">struct </span>State&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">pub </span>input: Box&lt;<span class="kw">dyn </span>BufRead + <span class="lifetime">&#39;a</span>&gt;,
    <span class="kw">pub </span>output: Box&lt;<span class="kw">dyn </span>Write + <span class="lifetime">&#39;a</span>&gt;,
    tape: [u8; TAPE_SIZE],
}

<span class="kw">struct </span>Program {
    code: dynasmrt::ExecutableBuffer,
    start: dynasmrt::AssemblyOffset,
}


<span class="kw">impl </span>Program {
    <span class="kw">fn </span>compile(program: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;Program, <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>ops = dynasmrt::x64::Assembler::new().unwrap();
        <span class="kw">let </span><span class="kw-2">mut </span>loops = Vec::new();
        <span class="kw">let </span><span class="kw-2">mut </span>code = multipeek(program.iter().cloned());

        <span class="kw">let </span>start = <span class="macro">prologue!</span>(ops);

        <span class="kw">while let </span><span class="prelude-val">Some</span>(c) = code.next() {
            <span class="kw">match </span>c {
                <span class="string">b&#39;&lt;&#39; </span>=&gt; {
                    <span class="kw">let </span>amount = code.take_while_ref(|x| <span class="kw-2">*</span>x == <span class="string">b&#39;&lt;&#39;</span>).count() + <span class="number">1</span>;
                    <span class="macro">my_dynasm!</span>(ops
                        ; sub a_current, (amount % TAPE_SIZE) <span class="kw">as _
                        </span>; cmp a_current, a_begin
                        ; jae &gt;wrap
                        ; add a_current, TAPE_SIZE <span class="kw">as _
                        </span>;wrap:
                    );
                }
                <span class="string">b&#39;&gt;&#39; </span>=&gt; {
                    <span class="kw">let </span>amount = code.take_while_ref(|x| <span class="kw-2">*</span>x == <span class="string">b&#39;&gt;&#39;</span>).count() + <span class="number">1</span>;
                    <span class="macro">my_dynasm!</span>(ops
                        ; add a_current, (amount % TAPE_SIZE) <span class="kw">as _
                        </span>; cmp a_current, a_end
                        ; jb &gt;wrap
                        ; sub a_current, TAPE_SIZE <span class="kw">as _
                        </span>;wrap:
                    );
                },
                <span class="string">b&#39;+&#39; </span>=&gt; {
                    <span class="kw">let </span>amount = code.take_while_ref(|x| <span class="kw-2">*</span>x == <span class="string">b&#39;+&#39;</span>).count() + <span class="number">1</span>;
                    <span class="kw">if </span>amount &gt; u8::MAX <span class="kw">as </span>usize {
                        <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="string">&quot;An overflow occurred&quot;</span>);
                    }
                    <span class="macro">my_dynasm!</span>(ops
                        ; add BYTE [a_current], amount <span class="kw">as _
                        </span>; jo -&gt;overflow
                    );
                },
                <span class="string">b&#39;-&#39; </span>=&gt; {
                    <span class="kw">let </span>amount = code.take_while_ref(|x| <span class="kw-2">*</span>x == <span class="string">b&#39;-&#39;</span>).count() + <span class="number">1</span>;
                    <span class="kw">if </span>amount &gt; u8::MAX <span class="kw">as </span>usize {
                        <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="string">&quot;An overflow occurred&quot;</span>);
                    }
                    <span class="macro">my_dynasm!</span>(ops
                        ; sub BYTE [a_current], amount <span class="kw">as _
                        </span>; jo -&gt;overflow
                    );
                },
                <span class="string">b&#39;,&#39; </span>=&gt; {
                    <span class="macro">my_dynasm!</span>(ops
                        ;; <span class="macro">call_extern!</span>(ops, State::getchar)
                        ; cmp al, <span class="number">0
                        </span>; jnz -&gt;io_failure
                    );
                },
                <span class="string">b&#39;.&#39; </span>=&gt; {
                    <span class="macro">my_dynasm!</span>(ops
                        ;; <span class="macro">call_extern!</span>(ops, State::putchar)
                        ; cmp al, <span class="number">0
                        </span>; jnz -&gt;io_failure
                    );
                },
                <span class="string">b&#39;[&#39; </span>=&gt; {
                    <span class="kw">let </span>first = code.peek() == <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b&#39;-&#39;</span>);
                    <span class="kw">if </span>first &amp;&amp; code.peek() == <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b&#39;]&#39;</span>) {
                        code.next();
                        code.next();
                        <span class="macro">my_dynasm!</span>(ops
                            ; mov BYTE [a_current], <span class="number">0
                        </span>);
                    } <span class="kw">else </span>{
                        <span class="kw">let </span>backward_label = ops.new_dynamic_label();
                        <span class="kw">let </span>forward_label = ops.new_dynamic_label();
                        loops.push((backward_label, forward_label));
                        <span class="macro">my_dynasm!</span>(ops
                            ; cmp BYTE [a_current], <span class="number">0
                            </span>; jz =&gt;forward_label
                            ;=&gt;backward_label
                        );
                    }
                },
                <span class="string">b&#39;]&#39; </span>=&gt; {
                    <span class="kw">if let </span><span class="prelude-val">Some</span>((backward_label, forward_label)) = loops.pop() {
                        <span class="macro">my_dynasm!</span>(ops
                            ; cmp BYTE [a_current], <span class="number">0
                            </span>; jnz =&gt;backward_label
                            ;=&gt;forward_label
                        );
                    } <span class="kw">else </span>{
                        <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="string">&quot;] without matching [&quot;</span>);
                    }
                },
                <span class="kw">_ </span>=&gt; (),
            }
        }
        <span class="kw">if </span>loops.len() != <span class="number">0 </span>{
            <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="string">&quot;[ without matching ]&quot;</span>);
        }

        <span class="macro">my_dynasm!</span>(ops
            ;; <span class="macro">epilogue!</span>(ops, <span class="number">0</span>)
            ;-&gt;overflow:
            ;; <span class="macro">epilogue!</span>(ops, <span class="number">1</span>)
            ;-&gt;io_failure:
            ;; <span class="macro">epilogue!</span>(ops, <span class="number">2</span>)
        );

        <span class="kw">let </span>code = ops.finalize().unwrap();
        <span class="prelude-val">Ok</span>(Program {
            code: code,
            start: start,
        })
    }

    <span class="kw">fn </span>run(<span class="self">self</span>, state: <span class="kw-2">&amp;mut </span>State) -&gt; <span class="prelude-ty">Result</span>&lt;(), <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str&gt; {
        <span class="kw">let </span>f: <span class="kw">extern </span><span class="string">&quot;win64&quot; </span><span class="kw">fn</span>(<span class="kw-2">*mut </span>State, <span class="kw-2">*mut </span>u8, <span class="kw-2">*mut </span>u8, <span class="kw-2">*const </span>u8) -&gt; u8 =
            <span class="kw">unsafe </span>{ mem::transmute(<span class="self">self</span>.code.ptr(<span class="self">self</span>.start)) };
        <span class="kw">let </span>start = state.tape.as_mut_ptr();
        <span class="kw">let </span>end = <span class="kw">unsafe </span>{ start.offset(TAPE_SIZE <span class="kw">as </span>isize) };
        <span class="kw">let </span>res = f(state, start, start, end);
        <span class="kw">if </span>res == <span class="number">0 </span>{
            <span class="prelude-val">Ok</span>(())
        } <span class="kw">else if </span>res == <span class="number">1 </span>{
            <span class="prelude-val">Err</span>(<span class="string">&quot;An overflow occurred&quot;</span>)
        } <span class="kw">else if </span>res == <span class="number">2 </span>{
            <span class="prelude-val">Err</span>(<span class="string">&quot;IO error&quot;</span>)
        } <span class="kw">else </span>{
            <span class="macro">panic!</span>(<span class="string">&quot;Unknown error code&quot;</span>);
        }
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; State&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">unsafe extern </span><span class="string">&quot;win64&quot; </span><span class="kw">fn </span>getchar(state: <span class="kw-2">*mut </span>State, cell: <span class="kw-2">*mut </span>u8) -&gt; u8 {
        <span class="kw">let </span>state = <span class="kw-2">&amp;mut *</span>state;
        <span class="kw">let </span>err = state.output.flush().is_err();
        (state.input.read_exact(slice::from_raw_parts_mut(cell, <span class="number">1</span>)).is_err() || err) <span class="kw">as </span>u8
    }

    <span class="kw">unsafe extern </span><span class="string">&quot;win64&quot; </span><span class="kw">fn </span>putchar(state: <span class="kw-2">*mut </span>State, cell: <span class="kw-2">*mut </span>u8) -&gt; u8 {
        <span class="kw">let </span>state = <span class="kw-2">&amp;mut *</span>state;
        state.output.write_all(slice::from_raw_parts(cell, <span class="number">1</span>)).is_err() <span class="kw">as </span>u8
    }

    <span class="kw">fn </span>new(input: Box&lt;<span class="kw">dyn </span>BufRead + <span class="lifetime">&#39;a</span>&gt;, output: Box&lt;<span class="kw">dyn </span>Write + <span class="lifetime">&#39;a</span>&gt;) -&gt; State&lt;<span class="lifetime">&#39;a</span>&gt; {
        State {
            input: input,
            output: output,
            tape: [<span class="number">0</span>; TAPE_SIZE],
        }
    }
}


<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>args: Vec&lt;<span class="kw">_</span>&gt; = env::args().collect();
    <span class="kw">if </span>args.len() != <span class="number">2 </span>{
        <span class="macro">println!</span>(<span class="string">&quot;Expected 1 argument, got {}&quot;</span>, args.len());
        <span class="kw">return</span>;
    }
    <span class="kw">let </span>path = args.pop().unwrap();

    <span class="kw">let </span><span class="kw-2">mut </span>f = <span class="kw">if let </span><span class="prelude-val">Ok</span>(f) = File::open(<span class="kw-2">&amp;</span>path) {
        f
    } <span class="kw">else </span>{
        <span class="macro">println!</span>(<span class="string">&quot;Could not open file {}&quot;</span>, path);
        <span class="kw">return</span>;
    };

    <span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();
    <span class="kw">if let </span><span class="prelude-val">Err</span>(<span class="kw">_</span>) = f.read_to_end(<span class="kw-2">&amp;mut </span>buf) {
        <span class="macro">println!</span>(<span class="string">&quot;Failed to read from file&quot;</span>);
        <span class="kw">return</span>;
    }

    <span class="kw">let </span><span class="kw-2">mut </span>state = State::new(Box::new(BufReader::new(stdin())),
                               Box::new(BufWriter::new(stdout())));
    <span class="kw">let </span>program = <span class="kw">match </span>Program::compile(<span class="kw-2">&amp;</span>buf) {
        <span class="prelude-val">Ok</span>(p) =&gt; p,
        <span class="prelude-val">Err</span>(e) =&gt; {
            <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, e);
            <span class="kw">return</span>;
        }
    };
    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = program.run(<span class="kw-2">&amp;mut </span>state) {
        <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, e);
        <span class="kw">return</span>;
    }
}</code></pre></div>

    </section>
<script type="text/javascript">
// make diffs look better, I can't do this in css for some reason and I don't want to hack it into rustdocs

document.addEventListener("DOMContentLoaded", function() {

    var old = document.querySelectorAll("code.language-diffold");
    var old_pre = [];
    for (var i = 0; i < old.length; i++) {
        var old_pre = old[i].parentNode;
        var new_pre = old_pre.nextElementSibling;
        if (new_pre && new_pre.childNodes.length > 0 && new_pre.childNodes[0].className == "language-diffnew") {
            old_pre.className = "collapse-old";
            new_pre.className = "collapse-new";
        }
    }

});
</script>

</body>
</html>