extern crate memmap;
extern crate byteorder;

pub mod mmap;
pub mod components;
pub mod relocations;
pub mod x64;
pub mod x86;
pub mod aarch64;

pub use crate::mmap::ExecutableBuffer;
use crate::components::{MemoryManager, LabelRegistry, RelocRegistry, ManagedRelocs, PatchLoc};
use crate::relocations::Relocation;

use std::iter::Extend;
use std::sync::{Arc, RwLock, RwLockReadGuard};
use std::io;
use std::error;
use std::fmt;
use std::mem;

/// This macro takes a *const pointer from the source operand, and then casts it to the desired return type.
/// this allows it to be used as an easy shorthand for passing pointers as dynasm immediate arguments.
#[macro_export]
macro_rules! Pointer {
    ($e:expr) => {$e as *const _ as _};
}

/// Preforms the same action as the `Pointer!` macro, but casts to a *mut pointer.
#[macro_export]
macro_rules! MutPointer {
    ($e:expr) => {$e as *mut _ as _};
}


/// A struct representing an offset into the assembling buffer of a `DynasmLabelApi` struct.
/// The wrapped `usize` is the offset from the start of the assembling buffer in bytes.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AssemblyOffset(pub usize);

/// A dynamic label
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct DynamicLabel(usize);


/// A read-only shared reference to the executable buffer inside an Assembler. By
/// locking it the internal `ExecutableBuffer` can be accessed and executed.
#[derive(Debug, Clone)]
pub struct Executor {
    execbuffer: Arc<RwLock<ExecutableBuffer>>
}

/// A read-only lockable reference to the internal `ExecutableBuffer` of an Assembler.
/// To gain access to this buffer, it must be locked.
impl Executor {
    /// Gain read-access to the internal `ExecutableBuffer`. While the returned guard
    /// is alive, it can be used to read and execute from the `ExecutableBuffer`.
    /// Any pointers created to the `Executablebuffer` should no longer be used when
    /// the guard is dropped.
    #[inline]
    pub fn lock(&self) -> RwLockReadGuard<ExecutableBuffer> {
        self.execbuffer.read().unwrap()
    }
}


/// The various error types generated by dynasm functions.
#[derive(Debug, Clone)]
pub enum DynasmError {
    /// A check (like `Modifier::check` or `Modifier::check_exact`) that failed
    CheckFailed,
    /// A duplicate label dynamic/global label was defined
    DuplicateLabel
}

impl fmt::Display for DynasmError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            DynasmError::CheckFailed => write!(f, "An assembly modification check failed"),
            DynasmError::DuplicateLabel => write!(f, "Duplicate label defined"),
        }
    }
}

impl error::Error for DynasmError {
    fn description(&self) -> &str {
        match *self {
            DynasmError::CheckFailed => "An assembly modification offset check failed",
            DynasmError::DuplicateLabel => "Duplicate label defined",
        }
    }
}


/// This trait represents the interface that must be implemented to allow
/// the dynasm preprocessor to assemble into a datastructure.
pub trait DynasmApi: Extend<u8> + for<'a> Extend<&'a u8> {
    /// Report the current offset into the assembling target
    fn offset(&self) -> AssemblyOffset;
    /// Push a byte into the assembling target
    fn push(&mut self, byte: u8);
    /// Push filler until the assembling target end is aligned to the given alignment.
    fn align(&mut self, alignment: usize, with: u8);

    #[inline]
    /// Push a signed byte into the assembling target
    fn push_i8(&mut self, value: i8) {
        self.push(value as u8);
    }
    /// Push a signed word into the assembling target
    #[inline]
    fn push_i16(&mut self, value: i16) {
        self.extend(&value.to_le_bytes());
    }
    /// Push a signed doubleword into the assembling target
    #[inline]
    fn push_i32(&mut self, value: i32) {
        self.extend(&value.to_le_bytes());
    }
    /// Push a signed quadword into the assembling target
    #[inline]
    fn push_i64(&mut self, value: i64) {
        self.extend(&value.to_le_bytes());
    }
    /// Push an usigned word into the assembling target
    #[inline]
    fn push_u16(&mut self, value: u16) {
        self.extend(&value.to_le_bytes());
    }
    /// Push an usigned doubleword into the assembling target
    #[inline]
    fn push_u32(&mut self, value: u32) {
        self.extend(&value.to_le_bytes());
    }
    /// Push an usigned quadword into the assembling target
    #[inline]
    fn push_u64(&mut self, value: u64) {
        self.extend(&value.to_le_bytes());
    }
    /// This function is called in when a runtime error has to be generated. It panics.
    #[inline]
    fn runtime_error(&self, msg: &'static str) -> ! {
        panic!(msg);
    }
}

/// This trait extends DynasmApi to not only allow assembling, but also labels and various directives
pub trait DynasmLabelApi : DynasmApi {
    /// The relocation info type this assembler uses. 
    type Relocation: Relocation;

    /// Record the definition of a local label
    fn local_label(  &mut self, name: &'static str);
    /// Record the definition of a global label
    fn global_label( &mut self, name: &'static str);
    /// Record the definition of a dynamic label
    fn dynamic_label(&mut self, id: DynamicLabel);

    /// Record a relocation spot for a forward reference to a local label
    fn forward_reloc( &mut self, name: &'static str, kind: <Self::Relocation as Relocation>::Encoding);
    /// Record a relocation spot for a backward reference to a local label
    fn backward_reloc(&mut self, name: &'static str, kind: <Self::Relocation as Relocation>::Encoding);
    /// Record a relocation spot for a reference to a global label
    fn global_reloc(  &mut self, name: &'static str, kind: <Self::Relocation as Relocation>::Encoding);
    /// Record a relocation spot for a reference to a dynamic label
    fn dynamic_reloc( &mut self, id: DynamicLabel,   kind: <Self::Relocation as Relocation>::Encoding);
    /// Record a relocation spot to an arbitrary target.
    fn bare_reloc(    &mut self, target: usize,      kind: <Self::Relocation as Relocation>::Encoding);
}


/// An assembler that is purely a `Vec<u8>`. It doesn't support labels, but can be used to easily inspect generated code.
pub struct VecAssembler(Vec<u8>);

impl Extend<u8> for VecAssembler {
    fn extend<T>(&mut self, iter: T) where T: IntoIterator<Item=u8> {
        self.0.extend(iter)
    }
}

impl<'a> Extend<&'a u8> for VecAssembler {
    fn extend<T>(&mut self, iter: T) where T: IntoIterator<Item=&'a u8> {
        self.0.extend(iter)
    }
}

impl DynasmApi for VecAssembler {
    fn offset(&self) -> AssemblyOffset {
        AssemblyOffset(self.0.len())
    }
    fn push(&mut self, byte: u8) {
        self.0.push(byte);
    }
    fn align(&mut self, alignment: usize, with: u8) {
        let offset = self.offset().0 % alignment;
        if offset != 0 {
            for _ in offset .. alignment {
                self.push(with);
            }
        }
    }
}

/// A full assembler implementation. Supports labels, all types of relocations,
/// incremental compilation and multithreaded execution with simultaneous compiltion.
/// Its implementation guarantees no memory is executable and writable at the same time.
#[derive(Debug)]
pub struct Assembler<R: Relocation> {
    ops: Vec<u8>,
    memory: MemoryManager,
    labels: LabelRegistry,
    relocs: RelocRegistry<R>,
    managed: ManagedRelocs<R>
}

impl<R: Relocation> Assembler<R> {
    /// Create a new, empty assembler, with initial allocation size `page_size`.
    pub fn new() -> io::Result<Self> {
        Ok(Self {
            ops: Vec::new(),
            memory: MemoryManager::new(R::page_size())?,
            labels: LabelRegistry::new(),
            relocs: RelocRegistry::new(),
            managed: ManagedRelocs::new()
        })
    }

    /// Create a new dynamic label ID
    pub fn new_dynamic_label(&mut self) -> DynamicLabel {
        self.labels.new_dynamic_label()
    }

    /// Use an `UncommittedModifier` to alter uncommitted code.
    /// This does not allow the user to change labels/relocations.
    pub fn alter_uncommitted(&mut self) -> UncommittedModifier {
        let offset = self.memory.committed();
        UncommittedModifier::new(&mut self.ops, AssemblyOffset(offset))
    }

    /// Use a `Modifier` to alter committed code directly. While this is happening
    /// no code can be executed as the relevant pages are remapped as writable.
    /// This API supports defining new labels/relocations, and overwriting previously defined relocations.
    pub fn alter<F, O>(&mut self, f: F) -> O
    where F: FnOnce(&mut Modifier<R>) -> O {
        self.commit();

        // swap out a buffer from base
        let mut lock = self.memory.write();
        let buffer = mem::replace(&mut *lock, ExecutableBuffer::default());
        let mut buffer = buffer.make_mut().expect("Could not swap buffer protection modes");

        let mut modifier = Modifier {
            asmoffset: 0,
            previous_asmoffset: 0,
            buffer: &mut *buffer,

            labels: &mut self.labels,
            relocs: &mut self.relocs,
            old_managed: &mut self.managed,
            new_managed: ManagedRelocs::new()
        };

        // execute the user code
        let output = f(&mut modifier);

        // flush any changes made by the user code to the buffer
        modifier.encode_relocs();

        // repack the buffer
        let buffer = buffer.make_exec().expect("Could not swap buffer protection modes");
        mem::replace(&mut *lock, buffer);

        // call it a day
        output
    }

    /// Commit code, flushing the temporary internal assembling buffer to the mapped executable memory.
    /// This makes assembled code available for execution.
    pub fn commit(&mut self) {
        self.encode_relocs();

        let managed = &self.managed;

        self.memory.commit(&mut self.ops, |buffer, old_addr, new_addr| {
            let change = new_addr.wrapping_sub(old_addr) as isize;

            for reloc in managed.iter() {
                reloc.adjust(0, buffer, change);
            }
        });
    }

    /// Finalize this assembler, returning the internal executablebuffer if no Executor instances exist.
    pub fn finalize(mut self) -> Result<ExecutableBuffer, Self> {
        self.commit();
        match self.memory.finalize() {
            Ok(execbuffer) => Ok(execbuffer),
            Err(memory) => Err(Self {
                memory,
                ..self
            })
        }
    }

    /// Create an executor which can be used to execute code while still assembling code
    pub fn reader(&self) -> Executor {
        Executor {
            execbuffer: self.memory.reader()
        }
    }

    /// Provides access to the assemblers internal labels registry
    pub fn labels(&self) -> &LabelRegistry {
        &self.labels
    }

    /// Provides mutable access to the assemblers internal labels registry
    pub fn labels_mut(&mut self) -> &mut LabelRegistry {
        &mut self.labels
    }

    // encode uncommited relocations
    fn encode_relocs(&mut self) {
        let buf_offset = self.memory.committed();
        let buf_addr = self.memory.execbuffer_addr();
        let buf = &mut self.ops;

        for (loc, name) in self.relocs.take_globals() {
            let target = self.labels.resolve_global(name).unwrap();
            loc.patch(buf_offset, buf_addr, buf, target.0);
            if loc.needs_adjustment() {
                self.managed.add(loc)
            }
        }

        for (loc, id) in self.relocs.take_dynamics() {
            let target = self.labels.resolve_dynamic(id).unwrap();
            loc.patch(buf_offset, buf_addr, buf, target.0);
            if loc.needs_adjustment() {
                self.managed.add(loc)
            }
        }

        for (_, name) in self.relocs.take_locals() {
            panic!("Unknown local label '{}'", name);
        }
    }
}

impl<R: Relocation> Extend<u8> for Assembler<R> {
    fn extend<T>(&mut self, iter: T) where T: IntoIterator<Item=u8> {
        self.ops.extend(iter)
    }
}

impl<'a, R: Relocation> Extend<&'a u8> for Assembler<R> {
    fn extend<T>(&mut self, iter: T) where T: IntoIterator<Item=&'a u8> {
        self.ops.extend(iter)
    }
}

impl<R: Relocation> DynasmApi for Assembler<R> {
    fn offset(&self) -> AssemblyOffset {
        AssemblyOffset(self.memory.committed() + self.ops.len())
    }

    fn push(&mut self, value: u8) {
        self.ops.push(value);
    }

    fn align(&mut self, alignment: usize, with: u8) {
        let misalign = self.offset().0 % alignment;
        if misalign != 0 {
            for _ in misalign .. alignment {
                self.push(with);
            }
        }
    }
}

impl<R: Relocation> DynasmLabelApi for Assembler<R> {
    type Relocation = R;

    fn local_label(&mut self, name: &'static str) {
        let offset = self.offset();
        for loc in self.relocs.take_locals_named(name) {
            loc.patch(self.memory.committed(), self.memory.execbuffer_addr(), &mut self.ops, offset.0);
            if loc.needs_adjustment() {
                self.managed.add(loc)
            }
        }
        self.labels.define_local(name, offset);
    }
    fn global_label( &mut self, name: &'static str) {
        let offset = self.offset();
        self.labels.define_global(name, offset).unwrap();
    }
    fn dynamic_label(&mut self, id: DynamicLabel) {
        let offset = self.offset();
        self.labels.define_dynamic(id, offset).unwrap();
    }
    fn global_reloc(&mut self, name: &'static str, kind: R::Encoding) {
        let offset = self.offset();
        self.relocs.add_global(name, PatchLoc::new(offset, R::from_encoding(kind)));
    }
    fn dynamic_reloc(&mut self, id: DynamicLabel, kind: R::Encoding) {
        let offset = self.offset();
        self.relocs.add_dynamic(id, PatchLoc::new(offset, R::from_encoding(kind)));
    }
    fn forward_reloc(&mut self, name: &'static str, kind: R::Encoding) {
        let offset = self.offset();
        self.relocs.add_local(name, PatchLoc::new(offset, R::from_encoding(kind)));
    }
    fn backward_reloc(&mut self, name: &'static str, kind: R::Encoding) {
        let target = self.labels.resolve_local(name).unwrap().0;
        let offset = self.offset();
        let loc = PatchLoc::new(
            offset,
            R::from_encoding(kind)
        );
        loc.patch(self.memory.committed(), self.memory.execbuffer_addr(), &mut self.ops, target);
        if loc.needs_adjustment() {
            self.managed.add(loc)
        }
    }
    fn bare_reloc(&mut self, target: usize, kind: R::Encoding) {
        let offset = self.offset();
        let loc = PatchLoc::new(
            offset,
            R::from_encoding(kind)
        );
        loc.patch(self.memory.committed(), self.memory.execbuffer_addr(), &mut self.ops, target);
        if loc.needs_adjustment() {
            self.managed.add(loc)
        }
    }
}


/// Allows modification of already committed assembly code. Contains an internal cursor
/// into the emitted assembly, initialized to the start, that can be moved around either with the
/// `goto` function, or just by assembling new code into this `Modifier`.
#[derive(Debug)]
pub struct Modifier<'a, R: Relocation> {
    asmoffset: usize,
    previous_asmoffset: usize,
    buffer: &'a mut [u8],

    labels: &'a mut LabelRegistry,
    relocs: &'a mut RelocRegistry<R>,
    old_managed: &'a mut ManagedRelocs<R>,
    new_managed: ManagedRelocs<R>
}

impl<'a, R: Relocation> Modifier<'a, R> {
    /// Move the modifier cursor to the selected location.
    pub fn goto(&mut self, offset: AssemblyOffset) {
        self.old_managed.remove_between(self.previous_asmoffset, self.asmoffset);
        self.asmoffset = offset.0;
        self.previous_asmoffset = offset.0;
    }

    /// Check that the modifier cursor has not moved past the specified location.
    pub fn check(&self, offset: AssemblyOffset) -> Result<(), DynasmError> {
        if self.asmoffset > offset.0 {
            Err(DynasmError::CheckFailed)
        } else {
            Ok(())
        }
    }

    /// Check that the modifier cursor is exactly at the specified location.
    pub fn check_exact(&self, offset: AssemblyOffset) -> Result<(), DynasmError> {
        if self.asmoffset != offset.0 {
            Err(DynasmError::CheckFailed)
        } else {
            Ok(())
        }
    }

    // encode uncommited relocations
    fn encode_relocs(&mut self) {
        let buf_addr = self.buffer.as_ptr() as usize;

        for (loc, name) in self.relocs.take_globals() {
            let target = self.labels.resolve_global(name).unwrap();
            loc.patch(0, buf_addr, self.buffer, target.0);
            if loc.needs_adjustment() {
                self.new_managed.add(loc)
            }
        }

        for (loc, id) in self.relocs.take_dynamics() {
            let target = self.labels.resolve_dynamic(id).unwrap();
            loc.patch(0, buf_addr, self.buffer, target.0);
            if loc.needs_adjustment() {
                self.new_managed.add(loc)
            }
        }

        for (_, name) in self.relocs.take_locals() {
            panic!("Unknown local label '{}'", name);
        }

        self.old_managed.remove_between(self.previous_asmoffset, self.asmoffset);
        self.previous_asmoffset = self.asmoffset;

        self.old_managed.append(&mut self.new_managed);
    }
}

impl<'a, R: Relocation> Extend<u8> for Modifier<'a,R> {
    fn extend<T>(&mut self, iter: T) where T: IntoIterator<Item=u8> {
        for (src, dst) in iter.into_iter().zip(self.buffer[self.asmoffset ..].iter_mut()) {
            *dst = src;
        }
    }
}

impl<'a, 'b, R: Relocation> Extend<&'b u8> for Modifier<'a, R> {
    fn extend<T>(&mut self, iter: T) where T: IntoIterator<Item=&'b u8> {
        for (src, dst) in iter.into_iter().zip(self.buffer[self.asmoffset ..].iter_mut()) {
            *dst = *src;
        }
    }
}

impl<'a, R: Relocation> DynasmApi for Modifier<'a, R> {
    fn offset(&self) -> AssemblyOffset {
        AssemblyOffset(self.asmoffset)
    }

    fn push(&mut self, value: u8) {
        self.buffer[self.asmoffset] = value;
        self.asmoffset += 1
    }

    fn align(&mut self, alignment: usize, with: u8) {
        let mismatch = self.asmoffset % alignment;
        if mismatch != 0 {
            for _ in mismatch .. alignment {
                self.push(with)
            }
        }
    }
}

impl<'a, R: Relocation> DynasmLabelApi for Modifier<'a, R> {
    type Relocation = R;

    fn local_label(&mut self, name: &'static str) {
        let offset = self.offset();
        for loc in self.relocs.take_locals_named(name) {
            loc.patch(0, self.buffer.as_ptr() as usize, self.buffer, offset.0);
            if loc.needs_adjustment() {
                self.new_managed.add(loc)
            }
        }
        self.labels.define_local(name, offset);
    }
    fn global_label( &mut self, name: &'static str) {
        let offset = self.offset();
        self.labels.define_global(name, offset).unwrap();
    }
    fn dynamic_label(&mut self, id: DynamicLabel) {
        let offset = self.offset();
        self.labels.define_dynamic(id, offset).unwrap();
    }
    fn global_reloc(&mut self, name: &'static str, kind: R::Encoding) {
        let offset = self.offset();
        self.relocs.add_global(name, PatchLoc::new(offset, R::from_encoding(kind)));
    }
    fn dynamic_reloc(&mut self, id: DynamicLabel, kind: R::Encoding) {
        let offset = self.offset();
        self.relocs.add_dynamic(id, PatchLoc::new(offset, R::from_encoding(kind)));
    }
    fn forward_reloc(&mut self, name: &'static str, kind: R::Encoding) {
        let offset = self.offset();
        self.relocs.add_local(name, PatchLoc::new(offset, R::from_encoding(kind)));
    }
    fn backward_reloc(&mut self, name: &'static str, kind: R::Encoding) {
        let target = self.labels.resolve_local(name).unwrap().0;
        let offset = self.offset();
        let loc = PatchLoc::new(
            offset,
            R::from_encoding(kind)
        );
        loc.patch(0, self.buffer.as_ptr() as usize, self.buffer, target);
        if loc.needs_adjustment() {
            self.new_managed.add(loc)
        }
    }
    fn bare_reloc(&mut self, target: usize, kind: R::Encoding) {
        let offset = self.offset();
        let loc = PatchLoc::new(
            offset,
            R::from_encoding(kind)
        );
        loc.patch(0, self.buffer.as_ptr() as usize, self.buffer, target);
        if loc.needs_adjustment() {
            self.new_managed.add(loc)
        }
    }
}


/// This struct is a wrapper around an `Assembler` normally created using the
/// `Assembler.alter_uncommitted` method. It allows the user to edit parts
/// of the assembling buffer that cannot be determined easily or efficiently
/// in advance. Due to limitations of the label resolution algorithms, this
/// assembler does not allow labels to be used.
#[derive(Debug)]
pub struct UncommittedModifier<'a> {
    buffer: &'a mut Vec<u8>,
    base_offset: usize,
    offset: usize
}

impl<'a> UncommittedModifier<'a> {
    /// create a new uncommittedmodifier
    pub fn new(buffer: &mut Vec<u8>, base_offset: AssemblyOffset) -> UncommittedModifier {
        UncommittedModifier {
            buffer: buffer,
            base_offset: base_offset.0,
            offset: base_offset.0
        }
    }

    /// Sets the current modification offset to the given value
    pub fn goto(&mut self, offset: AssemblyOffset) {
        self.offset = offset.0;
    }

    /// Checks that the current modification offset is not larger than the specified offset.
    pub fn check(&mut self, offset: AssemblyOffset) -> Result<(), DynasmError> {
        if self.offset > offset.0 {
            Err(DynasmError::CheckFailed)
        } else {
            Ok(())
        }
    }

    /// Checks that the current modification offset is exactly the specified offset.
    pub fn check_exact(&mut self, offset: AssemblyOffset) -> Result<(), DynasmError> {
        if self.offset != offset.0 {
            Err(DynasmError::CheckFailed)
        } else {
            Ok(())
        }
    }
}

impl<'a> DynasmApi for UncommittedModifier<'a> {
    fn offset(&self) -> AssemblyOffset {
        AssemblyOffset(self.offset)
    }

    fn push(&mut self, value: u8) {
        self.buffer[self.offset - self.base_offset] = value;
        self.offset += 1;
    }

    fn align(&mut self, alignment: usize, with: u8) {
        let mismatch = self.offset % alignment;
        if mismatch != 0 {
            for _ in mismatch .. alignment {
                self.push(with)
            }
        }
    }
}

impl<'a> Extend<u8> for UncommittedModifier<'a> {
    fn extend<T>(&mut self, iter: T) where T: IntoIterator<Item=u8> {
        for i in iter {
            self.push(i)
        }
    }
}

impl<'a, 'b> Extend<&'b u8> for UncommittedModifier<'a> {
    fn extend<T>(&mut self, iter: T) where T: IntoIterator<Item=&'b u8> {
        self.extend(iter.into_iter().cloned())
    }
}
