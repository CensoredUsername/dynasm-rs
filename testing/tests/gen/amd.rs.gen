
#[test]
fn enc_amd_clzero4118() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; clzero
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xFC", "clzero");
}



#[test]
fn enc_amd_invlpga4119() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; invlpga rax, ecx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xDF", "invlpga rax, ecx");
}



#[test]
fn enc_amd_invlpga4120() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; invlpga
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xDF", "invlpga");
}



#[test]
fn enc_amd_lfence4121() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; lfence
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0xAE, 0xE8", "lfence");
}



#[test]
fn enc_amd_llwpcb4122() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; llwpcb rbx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x8F, 0xE9, 0xF8, 0x12, 0xC3", "llwpcb rbx");
}



#[test]
fn enc_amd_llwpcb4123() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; llwpcb rcx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x8F, 0xE9, 0xF8, 0x12, 0xC1", "llwpcb rcx");
}



#[test]
fn enc_amd_llwpcb4124() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; llwpcb rdx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x8F, 0xE9, 0xF8, 0x12, 0xC2", "llwpcb rdx");
}



#[test]
fn enc_amd_lzcnt4125() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; lzcnt rdx, QWORD [rax * 2 + rdx]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x48, 0x0F, 0xBD, 0x14, 0x42", "lzcnt rdx, QWORD [rax * 2 + rdx]");
}



#[test]
fn enc_amd_lzcnt4126() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; lzcnt rax, QWORD [rax * 2 + rdx]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x48, 0x0F, 0xBD, 0x04, 0x42", "lzcnt rax, QWORD [rax * 2 + rdx]");
}



#[test]
fn enc_amd_lzcnt4127() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; lzcnt rbx, QWORD [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x48, 0x0F, 0xBD, 0x18", "lzcnt rbx, QWORD [rax]");
}



#[test]
fn enc_amd_lzcnt4128() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; lzcnt rdx, QWORD [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x48, 0x0F, 0xBD, 0x10", "lzcnt rdx, QWORD [rax]");
}



#[test]
fn enc_amd_lzcnt4129() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; lzcnt rax, rcx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x48, 0x0F, 0xBD, 0xC1", "lzcnt rax, rcx");
}



#[test]
fn enc_amd_mfence4130() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; mfence
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0xAE, 0xF0", "mfence");
}



#[test]
fn enc_amd_monitorx4131() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; monitorx rax, ecx, edx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xFA", "monitorx rax, ecx, edx");
}



#[test]
fn enc_amd_monitorx4132() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; monitorx ax, ecx, edx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xFA", "monitorx ax, ecx, edx");
}



#[test]
fn enc_amd_monitorx4133() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; monitorx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xFA", "monitorx");
}



#[test]
fn enc_amd_mwaitx4134() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; mwaitx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xFB", "mwaitx");
}



#[test]
fn enc_amd_mwaitx4135() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; mwaitx eax, ecx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xFB", "mwaitx eax, ecx");
}



#[test]
fn enc_amd_sfence4136() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; sfence
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0xAE, 0xF8", "sfence");
}



#[test]
fn enc_amd_slwpcb4137() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; slwpcb rdx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x8F, 0xE9, 0xF8, 0x12, 0xCA", "slwpcb rdx");
}



#[test]
fn enc_amd_slwpcb4138() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; slwpcb rcx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x8F, 0xE9, 0xF8, 0x12, 0xC9", "slwpcb rcx");
}



#[test]
fn enc_amd_syscall4139() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; syscall
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x05", "syscall");
}



#[test]
fn enc_amd_sysret4140() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; sysret
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x07", "sysret");
}


