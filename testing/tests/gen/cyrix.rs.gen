
#[test]
fn enc_cyrix_cpu_read3001() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; cpu_read
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x3D", "cpu_read");
}



#[test]
fn enc_cyrix_cpu_write3002() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; cpu_write
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x3C", "cpu_write");
}



#[test]
fn enc_cyrix_dmint3003() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; dmint
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x39", "dmint");
}



#[test]
fn enc_cyrix_montmul3004() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; montmul
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x0F, 0xA6, 0xC0", "montmul");
}



#[test]
fn enc_cyrix_rdm3005() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; rdm
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x3A", "rdm");
}



#[test]
fn enc_cyrix_rdshr3006() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; rdshr DWORD [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x36, 0x00", "rdshr DWORD [rax]");
}



#[test]
fn enc_cyrix_rdshr3007() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; rdshr eax
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x36, 0xC0", "rdshr eax");
}



#[test]
fn enc_cyrix_rsldt3008() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; rsldt TWORD [rax + 16]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x7B, 0x40, 0x10", "rsldt TWORD [rax + 16]");
}



#[test]
fn enc_cyrix_rsldt3009() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; rsldt TWORD [rax * 2 + rdx]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x7B, 0x04, 0x42", "rsldt TWORD [rax * 2 + rdx]");
}



#[test]
fn enc_cyrix_rsldt3010() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; rsldt TWORD [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x7B, 0x00", "rsldt TWORD [rax]");
}



#[test]
fn enc_cyrix_rsts3011() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; rsts TWORD [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x7D, 0x00", "rsts TWORD [rax]");
}



#[test]
fn enc_cyrix_rsts3012() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; rsts TWORD [rax + 16]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x7D, 0x40, 0x10", "rsts TWORD [rax + 16]");
}



#[test]
fn enc_cyrix_rsts3013() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; rsts TWORD [rax * 2 + rdx]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x7D, 0x04, 0x42", "rsts TWORD [rax * 2 + rdx]");
}



#[test]
fn enc_cyrix_smint3014() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; smint
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x38", "smint");
}



#[test]
fn enc_cyrix_svldt3015() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; svldt TWORD [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x7A, 0x00", "svldt TWORD [rax]");
}



#[test]
fn enc_cyrix_svldt3016() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; svldt TWORD [rax + 16]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x7A, 0x40, 0x10", "svldt TWORD [rax + 16]");
}



#[test]
fn enc_cyrix_svts3017() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; svts TWORD [rax * 2 + rdx]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x7C, 0x04, 0x42", "svts TWORD [rax * 2 + rdx]");
}



#[test]
fn enc_cyrix_svts3018() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; svts TWORD [rax + 16]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x7C, 0x40, 0x10", "svts TWORD [rax + 16]");
}



#[test]
fn enc_cyrix_wrshr3019() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; wrshr DWORD [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x37, 0x00", "wrshr DWORD [rax]");
}



#[test]
fn enc_cyrix_wrshr3020() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; wrshr eax
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x37, 0xC0", "wrshr eax");
}



#[test]
fn enc_cyrix_xcryptcbc3021() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; xcryptcbc
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x0F, 0xA7, 0xD0", "xcryptcbc");
}



#[test]
fn enc_cyrix_xcryptcfb3022() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; xcryptcfb
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x0F, 0xA7, 0xE0", "xcryptcfb");
}



#[test]
fn enc_cyrix_xcryptctr3023() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; xcryptctr
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x0F, 0xA7, 0xD8", "xcryptctr");
}



#[test]
fn enc_cyrix_xcryptecb3024() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; xcryptecb
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x0F, 0xA7, 0xC8", "xcryptecb");
}



#[test]
fn enc_cyrix_xcryptofb3025() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; xcryptofb
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x0F, 0xA7, 0xE8", "xcryptofb");
}



#[test]
fn enc_cyrix_xsha13026() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; xsha1
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x0F, 0xA6, 0xC8", "xsha1");
}



#[test]
fn enc_cyrix_xsha2563027() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; xsha256
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x0F, 0xA6, 0xD0", "xsha256");
}



#[test]
fn enc_cyrix_xstore3028() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; xstore
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0xA7, 0xC0", "xstore");
}


