
#[test]
fn enc_clgi3169() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; clgi
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xDD", "clgi");
}



#[test]
fn enc_invept3170() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; invept rdx, OWORD [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x66, 0x0F, 0x38, 0x80, 0x10", "invept rdx, OWORD [rax]");
}



#[test]
fn enc_invept3171() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; invept rcx, OWORD [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x66, 0x0F, 0x38, 0x80, 0x08", "invept rcx, OWORD [rax]");
}



#[test]
fn enc_invept3172() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; invept rax, OWORD [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x66, 0x0F, 0x38, 0x80, 0x00", "invept rax, OWORD [rax]");
}



#[test]
fn enc_invvpid3173() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; invvpid rdx, OWORD [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x66, 0x0F, 0x38, 0x81, 0x10", "invvpid rdx, OWORD [rax]");
}



#[test]
fn enc_invvpid3174() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; invvpid rax, OWORD [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x66, 0x0F, 0x38, 0x81, 0x00", "invvpid rax, OWORD [rax]");
}



#[test]
fn enc_invvpid3175() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; invvpid rcx, OWORD [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x66, 0x0F, 0x38, 0x81, 0x08", "invvpid rcx, OWORD [rax]");
}



#[test]
fn enc_stgi3176() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; stgi
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xDC", "stgi");
}



#[test]
fn enc_vmcall3177() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmcall
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xC1", "vmcall");
}



#[test]
fn enc_vmclear3178() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmclear [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x66, 0x0F, 0xC7, 0x30", "vmclear [rax]");
}



#[test]
fn enc_vmfunc3179() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmfunc
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xD4", "vmfunc");
}



#[test]
fn enc_vmlaunch3180() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmlaunch
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xC2", "vmlaunch");
}



#[test]
fn enc_vmload3181() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmload
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xDA", "vmload");
}



#[test]
fn enc_vmmcall3182() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmmcall
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xD9", "vmmcall");
}



#[test]
fn enc_vmptrld3183() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmptrld [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0xC7, 0x30", "vmptrld [rax]");
}



#[test]
fn enc_vmptrst3184() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmptrst [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0xC7, 0x38", "vmptrst [rax]");
}



#[test]
fn enc_vmread3185() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmread [rax], rax
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x78, 0x00", "vmread [rax], rax");
}



#[test]
fn enc_vmread3186() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmread rax, rcx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x78, 0xC8", "vmread rax, rcx");
}



#[test]
fn enc_vmread3187() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmread [rax], rcx
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x78, 0x08", "vmread [rax], rcx");
}



#[test]
fn enc_vmread3188() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmread rax, rax
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x78, 0xC0", "vmread rax, rax");
}



#[test]
fn enc_vmresume3189() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmresume
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xC3", "vmresume");
}



#[test]
fn enc_vmrun3190() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmrun
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xD8", "vmrun");
}



#[test]
fn enc_vmsave3191() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmsave
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xDB", "vmsave");
}



#[test]
fn enc_vmwrite3192() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmwrite rcx, [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x79, 0x08", "vmwrite rcx, [rax]");
}



#[test]
fn enc_vmwrite3193() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmwrite rcx, rax
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x79, 0xC8", "vmwrite rcx, rax");
}



#[test]
fn enc_vmwrite3194() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmwrite rax, rax
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x79, 0xC0", "vmwrite rax, rax");
}



#[test]
fn enc_vmwrite3195() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmwrite rdx, [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x79, 0x10", "vmwrite rdx, [rax]");
}



#[test]
fn enc_vmxoff3196() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmxoff
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0x0F, 0x01, 0xC4", "vmxoff");
}



#[test]
fn enc_vmxon3197() {
     let mut ops = dynasmrt::x64::Assembler::new();
     dynasm!(ops
             ; vmxon [rax]
     );
     let buf = ops.finalize().unwrap();
     let hex: Vec<String> = buf.iter().map(|x| format!("0x{:02X}", *x)).collect();
     let hex: String = hex.join(", ");
     assert_eq!(hex, "0xF3, 0x0F, 0xC7, 0x30", "vmxon [rax]");
}


